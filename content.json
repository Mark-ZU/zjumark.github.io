{"meta":{"title":"Mark's Page","subtitle":null,"description":null,"author":null,"url":"http://zjumark.github.io"},"pages":[{"title":"Repositories","date":"2018-11-02T10:39:06.833Z","updated":"2018-11-02T09:00:48.527Z","comments":false,"path":"repository/index.html","permalink":"http://zjumark.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"QtQuick(Qml)中的Model使用","slug":"QtQuick-Qml-中的Model使用","date":"2018-11-25T15:20:02.000Z","updated":"2018-11-25T15:22:27.017Z","comments":true,"path":"2018/11/25/QtQuick-Qml-中的Model使用/","link":"","permalink":"http://zjumark.github.io/2018/11/25/QtQuick-Qml-中的Model使用/","excerpt":"","text":"在Qml使用中，会遇到使用Repeater或者ListView之类的东西，如果这些需要展示的数据在c++层面，数据的频繁更新或者数据的惰性更新会需要使用到Model。 与Model对应一起使用的是Delegate，分别代表的是数据原型以及显示方式，这非常符合MVC。(相关概念及使用样例) 在Qml中，更复杂的Model需要有c++ class来书写，本文提供一种方便与c++数据进行交互的方法。 1234567891011121314151617181920class Global : public QObject&#123; Q_OBJECTsignals: void widthChanged(int);&#125;;typedef Singleton&lt;Global&gt; G;class DataModel : public QAbstractListModel&#123; Q_OBJECTpublic slots: void widthChanged(int i)&#123; emit dataChanged(createIndex(i,0),createIndex(i,0)); &#125;public: explicit DataModel(QObject *parent = Q_NULLPTR); virtual ~DataModel()&#123;&#125; enum Roles &#123; WidthRole = Qt::UserRole + 1 &#125;; Q_ENUM(Roles) QHash&lt;int, QByteArray&gt; roleNames() const ; virtual int rowCount(const QModelIndex &amp;parent = QModelIndex()) const override; virtual int columnCount(const QModelIndex &amp;parent = QModelIndex()) const override; virtual QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const override;&#125;; 以上代码是一个Model的Demo样例，值得注意的是三个重载的函数rowCount、columnCount以及data和一个信号dataChanged，这三个函数是由Qml进行调用，获取Model的行列值以及获取特定位置的值的，而在行列值不变的情况下，需要更新数据只需要触发dataChanged信号即可。若出现了行列值改变的情况，则需要进行重新渲染，流程如下: 123456void reload()&#123; beginResetModel(); ... endResetModel(); this-&gt;resetInternalData();&#125; api函数均可以通过Qt Reference找到，这里就不详细解释了。 完整Demo地址","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-11-14T17:02:16.088Z","updated":"2018-11-14T17:02:16.088Z","comments":true,"path":"2018/11/15/hello-world/","link":"","permalink":"http://zjumark.github.io/2018/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Ubuntu下的alfred替代软件以及有道词典插件","slug":"Ubuntu下的alfred替代软件以及有道词典插件","date":"2018-11-14T17:00:23.000Z","updated":"2018-11-14T17:18:51.738Z","comments":true,"path":"2018/11/15/Ubuntu下的alfred替代软件以及有道词典插件/","link":"","permalink":"http://zjumark.github.io/2018/11/15/Ubuntu下的alfred替代软件以及有道词典插件/","excerpt":"","text":"习惯于Mac下alfred的使用后，换成Ubuntu或者Windows会时常想起这个快捷好用的软件，平常的计算器，应用搜索，甚至于查询天气，查字典，查api等都很顺手。在Windows下，可以使用Wox进行替代，在Ubuntu下可以使用Albert进行替代。 但是由于使用人数不是很多，插件不是非常完备，于是尝试从alfred抄过来一个查有道词典的插件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: utf-8 -*-\"\"\"Translate text using Youdao Translate API.Usage: yd &lt;text&gt;Example: yd hello\"\"\"from albertv0 import *import jsonimport urllib.requestimport urllib.parseimport hashlibimport locale__iid__ = \"PythonInterface/v0.1\"__prettyname__ = \"Youdao Translate\"__version__ = \"0.1\"__trigger__ = \"yd \" # 触发命令__author__ = \"mark\"__dependencies__ = []ua = \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36\"urltmpl = \"http://fanyi.youdao.com/openapi.do?keyfrom=SeekBetterMe&amp;key=164530784&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=%s\"iconPath = iconLookup('config-language') # 自定义图标if not iconPath: iconPath = \":python_module\"def handleQuery(query): if query.isTriggered: def getItem(text, subtext=''): # 显示的项 item = Item( id=__prettyname__, icon=iconPath, completion=query.rawString, text=text, subtext=subtext ) item.addAction(ClipAction(\"Copy translation to clipboard\", text)) # 项支持的操作 return item txt = query.string.strip() if txt: url = urltmpl % ( urllib.parse.quote_plus(txt) ) req = urllib.request.Request(url, headers=&#123;'User-Agent': ua&#125;) with urllib.request.urlopen(req) as response: items = [] # 待返回的列表 data = json.load(response) if 'basic' in data: if 'phonetic' in data['basic']: # 读音 items.append(getItem('/' + data['basic']['phonetic'] + '/')) for exp in data['basic']['explains']: # 释义 items.append(getItem(exp, 'basic')) elif 'translation' in data: # 句子翻译 items.append(getItem(data['translation'][0], 'translation')) if 'web' in data: # 网络释义 for w in data['web']: value = list(set(w['value'])) # 去重 items.append(getItem(w['key']+': '+'; '.join(value[:2]), 'web')) return items else: return getItem(\"Enter a translation query\") 由于之前在Mac下是直接使用写好的插件的，没有看过代码，这次查看了一下发现，使用了某位大佬之前注册的youdao/openapi的账号，目前这个账号已经停止注册并且使用有道智云代替，相当于已经没有免费的查询接口了（当然自己写爬虫也是没有问题的）。简单起见，依旧使用了某位大佬的账号（侵删hzypp@sina.cn)。效果如下，可以查看音标还蛮方便的。","categories":[],"tags":[]}]}